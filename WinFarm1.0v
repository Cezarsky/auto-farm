import time
import keyboard
import math
import minescript

# ===== USTAWIENIA =====
PLANT_AIM_Y = 1.12      # wyżej niż 1.0
PLANT_AIM_X_BIAS = 0.10 # w prawo (X)
PLANT_AIM_Z_BIAS = 0.00 # jeśli wolisz w prawo w Z, zmień tu




RADIUS = 3           # 7x7
TOGGLE_KEY = "p"
QUIT_KEY = "q"

LOOK_TICKS = 0
FARMLAND_Y_OFFSET = -1

MOVE_BLOCKS = 8.5
MOVE_TIME_PER_BLOCK = 0.17

SEED_ITEMS = {"minecraft:wheat_seeds"}
ALLOW_SWAP_FROM_INVENTORY = True        # True = może przerzucić do hotbaru, False = tylko hotbar

MIN_SEEDS_BEFORE_REFILL = 3       # kiedy uzupełniać (gdy <=)
REFILL_COOLDOWN_SEC = 0.5         # żeby nie spamować przerzucaniem

_last_refill_ts = 0.0

HOME_PREFIX = "farma"
home_counter = 1

ATTACK_TICKS = 2          # było 1 -> 2 zwykle mocno pomaga
HARVEST_PASSES_MAX = 2    # ile razy max powtórzyć zbiór, zanim przejdziemy dalej

HARVEST_MODE = "ALL_PLANTS"  # "MATURE_ONLY" albo "ALL_PLANTS"

BLACK_CONCRETE_ID = "minecraft:black_concrete"
LOBBY_WAIT_SECONDS = 30 * 60  # 30 minut

_in_lobby_wait = False  # flaga żeby nie odpalać pętli lobby co tick


# ===== POMOCNICZE =====
def check_black_concrete_lobby_wait():
    """
    Jeśli stoisz na black_concrete:
    - /home lobby
    - czekaj 30 min (z możliwością wyjścia Q)
    - /home farma
    Zwraca True jeśli wykonał akcję (czyli cykl ma być pominięty).
    """
    global _in_lobby_wait

    if _in_lobby_wait:
        return True

    block = block_under_player()
    if isinstance(block, str) and block.startswith(BLACK_CONCRETE_ID):
        _in_lobby_wait = True

        with minescript.tick_loop:
            minescript.execute("/home lobby")
        time.sleep(2.0)  # daj czas na teleport

        end_ts = time.time() + LOBBY_WAIT_SECONDS
        while time.time() < end_ts:
            if keyboard.is_pressed(QUIT_KEY):
                print("Exit during lobby wait.")
                raise SystemExit
            time.sleep(1.0)

        with minescript.tick_loop:
            minescript.execute("/home farma")
        time.sleep(2.0)  # daj czas na teleport

        _in_lobby_wait = False
        return True

    return False


def aim_point_for_plant(x, fy, z):
    # bazowo celujemy “bliżej gracza” jak wcześniej
    px, py, pz = minescript.player().position
    ax = x + (0.2 if px < x + 0.5 else 0.8)
    az = z + (0.2 if pz < z + 0.5 else 0.8)

    # przesunięcie bardziej w “prawy bok” (bias)
    ax = max(x + 0.05, min(x + 0.95, ax + PLANT_AIM_X_BIAS))
    az = max(z + 0.05, min(z + 0.95, az + PLANT_AIM_Z_BIAS))

    # wyżej
    ay = fy + PLANT_AIM_Y
    return ax, ay, az


def should_break_crop(block_id: str) -> bool:
    """
    block_id to string typu: 'minecraft:wheat[age=7]' albo 'minecraft:carrots[age=3]'
    """
    if not isinstance(block_id, str):
        return False

    # Puste pole
    if block_id.startswith("minecraft:air"):
        return False

    if HARVEST_MODE == "MATURE_ONLY":
        # tylko dojrzała pszenica
        return block_id.startswith("minecraft:wheat") and "age=7" in block_id

    # HARVEST_MODE == "ALL_PLANTS"
    # agresywnie: niszcz każdą roślinę na farmlandzie
    # (tu daję whitelistę typowych upraw — możesz rozszerzyć)
    crops = (
        "minecraft:wheat",
        "minecraft:carrots",
        "minecraft:potatoes",
        "minecraft:beetroots",
        "minecraft:nether_wart",
    )
    return block_id.startswith(crops)


def harvest_pass(cx, fy, cz):
    harvested = 0
    for dx in range(-RADIUS, RADIUS + 1):
        for dz in range(-RADIUS, RADIUS + 1):
            x = cx + dx
            z = cz + dz

            if not minescript.getblock(x, fy, z).startswith("minecraft:farmland"):
                continue

            above = minescript.getblock(x, fy + 1, z)
            if should_break_crop(above):
                ax, ay, az = aim_point_towards_player(x, fy, z)
                with minescript.tick_loop:
                    minescript.player_look_at(ax, ay, az)
                    minescript.player_press_attack(True)
                with minescript.tick_loop:
                    minescript.player_press_attack(False)

                harvested += 1
                time.sleep(0.007)
    return harvested



def block_under_player():
    px, py, pz = minescript.player().position
    bx = math.floor(px)
    bz = math.floor(pz)
    # blok pod stopami (najczęściej działa najlepiej)
    by = math.floor(py) - 1
    return minescript.getblock(bx, by, bz)

def every_10_cycles_commands(cycle):
    if cycle % 10 != 0:
        return

    with minescript.tick_loop:
        minescript.execute("/bloki")
    time.sleep(0.3)  # krótka pauza, żeby serwer zdążył

    with minescript.tick_loop:
        minescript.execute("/sellall")
    time.sleep(0.3)
    with minescript.tick_loop:
        minescript.chat("&c ===  &6 Darmowa Zarabiarka /is warp BestPlayerKrul &c ===")
    time.sleep(0.3)
    with minescript.tick_loop:
        minescript.execute("/day")




    time.sleep(0.3)


def check_red_concrete_and_home():
    global home_counter
    block = block_under_player()
    if isinstance(block, str) and block.startswith("minecraft:red_concrete"):
        cmd = f"/home {HOME_PREFIX}{home_counter}"
        with minescript.tick_loop:
            minescript.execute(cmd)
        home_counter += 1
        # mała pauza, żeby komenda „siadła”
        time.sleep(0.2)


def wait_one_tick():
    with minescript.tick_loop:
        pass

def refill_seeds_to_hotbar_if_needed():
    global _last_refill_ts
    now = time.time()

    held_item = get_main_hand_item_id()
    held_count = get_main_hand_count()

    # jeśli mamy seeds i > próg -> nie rób nic
    if held_item in SEED_ITEMS and held_count > MIN_SEEDS_BEFORE_REFILL:
        return True

    # cooldown tylko gdy nadal coś masz; gdy count==0 -> próbuj od razu
    if held_count > 0 and (now - _last_refill_ts) < REFILL_COOLDOWN_SEC:
        return True

    # 1) jeśli są seeds w hotbarze -> przełącz
    hotbar_slot = find_seed_in_hotbar()
    if hotbar_slot is not None:
        with minescript.tick_loop:
            minescript.player_inventory_select_slot(hotbar_slot)
        wait_one_tick()
        _last_refill_ts = now
        return (get_main_hand_item_id() in SEED_ITEMS and get_main_hand_count() > 0)

    # 2) jeśli nie ma w hotbarze -> spróbuj przerzucić z inventory do hotbara
    if ALLOW_SWAP_FROM_INVENTORY:
        inv_slot = find_seed_in_inventory_non_hotbar()
        if inv_slot is not None:
            with minescript.tick_loop:
                swapped_to = minescript.player_inventory_slot_to_hotbar(inv_slot)
                minescript.player_inventory_select_slot(swapped_to)
            wait_one_tick()
            _last_refill_ts = now
            return (get_main_hand_item_id() in SEED_ITEMS and get_main_hand_count() > 0)

    # 3) nie ma seeds nigdzie
    _last_refill_ts = now
    return False

def get_main_hand_count():
    hands = minescript.player_hand_items()
    mh = getattr(hands, "main_hand", None)
    return getattr(mh, "count", 0) if mh else 0


def get_main_hand_item_id():
    hands = minescript.player_hand_items()
    if hands is None:
        return None

    # u Ciebie: hands.main_hand to ItemStack albo None
    mh = getattr(hands, "main_hand", None)
    if mh is None:
        return None

    return getattr(mh, "item", None)

def find_seed_in_hotbar():
    inv = minescript.player_inventory()
    for it in inv:
        slot = getattr(it, "slot", None)
        item = getattr(it, "item", None)
        count = getattr(it, "count", 0)

        if slot is None or item is None:
            continue

        if 0 <= slot <= 8 and count > 0 and item in SEED_ITEMS:
            return slot
    return None

def find_seed_in_inventory_non_hotbar():
    inv = minescript.player_inventory()
    for it in inv:
        slot = getattr(it, "slot", None)
        item = getattr(it, "item", None)
        count = getattr(it, "count", 0)

        if slot is None or item is None:
            continue

        if slot >= 9 and count > 0 and item in SEED_ITEMS:
            return slot
    return None

def ensure_seeds_selected():
    """
    Upewnia się, że w main-hand masz nasiona:
    - jeśli już trzymasz nasiona -> True
    - jeśli są w hotbar -> przełącza slot -> True
    - jeśli nie ma w hotbar, ale są w inv i ALLOW_SWAP... -> przerzuca do hotbar i wybiera -> True
    - jeśli nie ma -> False
    """
    held = get_main_hand_item_id()
    if held in SEED_ITEMS and get_main_hand_count() > 0:
        return True

    hotbar_slot = find_seed_in_hotbar()
    if hotbar_slot is not None:
        minescript.player_inventory_select_slot(hotbar_slot)
        time.sleep(0.01)
        return True

    if ALLOW_SWAP_FROM_INVENTORY:
        inv_slot = find_seed_in_inventory_non_hotbar()
        if inv_slot is not None:
            swapped_to = minescript.player_inventory_slot_to_hotbar(inv_slot)
            minescript.player_inventory_select_slot(swapped_to)
            return True

    return False

def plant_one(x, fy, z):
    ax, ay, az = aim_point_for_plant(x, fy, z)
    with minescript.tick_loop:
        minescript.player_look_at(ax, ay, az)
        minescript.player_press_use(True)
    with minescript.tick_loop:
        minescript.player_press_use(False)

def get_center_block_floor():
    px, py, pz = minescript.player().position
    return math.floor(px), py, math.floor(pz)

def farmland_y(py):
    return round(py + FARMLAND_Y_OFFSET)

def aim_point_towards_player(x, fy, z):
    px, py, pz = minescript.player().position
    ax = x + (0.2 if px < x + 0.5 else 0.8)
    az = z + (0.2 if pz < z + 0.5 else 0.8)
    ay = fy + 1.0
    return ax, ay, az

def look_at(ax, ay, az, ticks=1):
    for _ in range(ticks):
        with minescript.tick_loop:
            minescript.player_look_at(ax, ay, az)

def use_once():
    with minescript.tick_loop:
        minescript.player_press_use(True)
    with minescript.tick_loop:
        minescript.player_press_use(False)

def attack_for_ticks(ticks=ATTACK_TICKS):
    for _ in range(ticks):
        with minescript.tick_loop:
            minescript.player_press_attack(True)
    with minescript.tick_loop:
        minescript.player_press_attack(False)

def count_mature_wheat(cx, fy, cz):
    cnt = 0
    for dx in range(-RADIUS, RADIUS + 1):
        for dz in range(-RADIUS, RADIUS + 1):
            x = cx + dx
            z = cz + dz
            if not minescript.getblock(x, fy, z).startswith("minecraft:farmland"):
                continue
            above = minescript.getblock(x, fy + 1, z)
            if should_break_crop(above):
                cnt += 1
    return cnt


# ===== LOGIKA FARMY =====

def harvest_then_plant_area(cx, cy, cz):
    # --- ZBIÓR ---
    fy = farmland_y(cy)
    harvested = 0
    planted = 0

    # --- ZBIÓR Z CHECKEREM (powtarzaj aż nie ma wheat[age=7]) ---
    for attempt in range(1, HARVEST_PASSES_MAX + 1):
        remaining = count_mature_wheat(cx, fy, cz)
        if remaining == 0:
            break

        got = harvest_pass(cx, fy, cz)
        harvested += got

        # opcjonalnie debug:
        # print(f"Harvest pass {attempt}: got={got}, remaining_before={remaining}")

        # jeśli pass nic nie zebrał mimo że coś było, nie ma sensu zapętlać
        if got == 0:
            break

    # --- ZASIEW ---
    for dx in range(-RADIUS, RADIUS + 1):
        for dz in range(-RADIUS, RADIUS + 1):
            x = cx + dx
            z = cz + dz

            if not minescript.getblock(x, fy, z).startswith("minecraft:farmland"):
                continue

            above = minescript.getblock(x, fy + 1, z)
            if above.startswith("minecraft:air"):

                ok = refill_seeds_to_hotbar_if_needed()
                if not ok:
                    return harvested, planted, True  # out_of_seeds=True

                ax, ay, az = aim_point_for_plant(x, fy, z)
                plant_one(x, fy, z)
                planted += 1

    return harvested, planted, False  # out_of_seeds=False

# ===== KONIEC CYKLU =====

def finish_cycle():
    # stały kierunek patrzenia
    with minescript.tick_loop:
        minescript.player_set_orientation(-90, 0)

    # przejście 7 bloków
    with minescript.tick_loop:
        minescript.player_press_forward(True)
    time.sleep(MOVE_BLOCKS * MOVE_TIME_PER_BLOCK)
    with minescript.tick_loop:
        minescript.player_press_forward(False)

# ===== MAIN LOOP =====

def main():
    print("[P] toggle loop | [Q] quit")
    enabled = False
    last_toggle = False
    cycle = 0

    while True:
        if keyboard.is_pressed(QUIT_KEY):
            print("Exit.")
            break
        # ✅ BLACK CONCRETE: lobby -> wait 30 min -> farma
        if check_black_concrete_lobby_wait():
            time.sleep(0.1)
            continue


        t = keyboard.is_pressed(TOGGLE_KEY)
        if t and not last_toggle:
            enabled = not enabled
            print("BOT:", "ON" if enabled else "OFF")
        last_toggle = t

        if enabled:
            cycle += 1
            cx, cy, cz = get_center_block_floor()
            harvested, planted, out_of_seeds = harvest_then_plant_area(cx, cy, cz)

            print(f"[Cycle {cycle}] harvested={harvested} | planted={planted} | out_of_seeds={out_of_seeds}")

            if not out_of_seeds:
                finish_cycle()
                check_red_concrete_and_home()
                every_10_cycles_commands(cycle)
            else:
                # zostań w miejscu i próbuj dalej (aż uzupełnisz seeds)
                time.sleep(0.5)
                continue

            print(
                f"[Cycle {cycle}] "
                f"harvested={harvested} | planted={planted}"
            )

        time.sleep(0.1)

if __name__ == "__main__":
    main()
